<ul>
<li><a href="#linux">Linux</a>
<ul>
<li><a href="#linux---modules">Modules</a></li>
<li><a href="#linux---i/o-schedulers">I/O Schedulers</a></li>
</ul></li>
<li><a href="#initial-ram-filesystem">Initial RAM Filesystem</a>
<ul>
<li><a href="#initial-ram-filesystem---arch-linux">Arch Linux (mkinitcpio)</a></li>
<li>Debian (initramfs-tools)</li>
<li><a href="#initial-ram-filesystem---rhel">RHEL (dracut)</a></li>
</ul></li>
</ul>
<h1 id="linux">Linux</h1>
<p>Linux is a kernel designed to be similar to the original Unix kernel, but modern, free and open source. It is built to work on many mondern proccessor aritecthures including the 32-bit and 64-bit versions of i386. This is also used to generally describe the many operating systems that use the Linux kernel. [1]</p>
<p>Source:</p>
<ol style="list-style-type: decimal">
<li>&quot;About Linux Kernel.&quot; The Linux Kernel Archives. Accessed November 19, 2016. https://www.kernel.org/linux.html</li>
</ol>
<h2 id="linux---modules">Linux - Modules</h2>
<p>The kernel is composed of a large number of modules. These can be found here:</p>
<pre><code>/lib/modules/&lt;KERNEL_VERSION&gt;/</code></pre>
<p>View all of the loaded moudles:</p>
<pre><code># lsmod</code></pre>
<p>Custom modules can be compiled for a specific kernel and copied in their respective driver directory. A few common drivers types are &quot;iscsi&quot;, &quot;net/ethernet&quot;, &quot;net/wireless&quot;, &quot;usb&quot;, &quot;pci&quot;, &quot;video&quot;, etc.</p>
<pre><code>/lib/modules/&lt;KERNEL_VERSION&gt;/kernel/drivers/&lt;DRIVER_TYPE&gt;/</code></pre>
<p>After copying over the necessary *.ko file(s) for custom modules, load</p>
<pre><code># depmod &lt;MODULE&gt;</code></pre>
<p>If there are a large number of new modules, it is possible to make sure all module depdendencies are installed.</p>
<pre><code># depmod --all</code></pre>
<p>Modules can be temporarily loaded:</p>
<pre><code># modprobe &lt;MODULE&gt;</code></pre>
<p>Or permanetly add the module to a file with the extension &quot;.conf&quot; in the modules load directory.</p>
<pre><code>/etc/modules-load.d/*.conf</code></pre>
<p>Modules can be deactivated by running one of these two commands:</p>
<pre><code># rmmod &lt;MODULE&gt;</code></pre>
<pre><code># modprobe -r &lt;MODULE&gt;</code></pre>
<p>Modules can also be blocked from starting on boot:</p>
<pre><code>/etc/modprobe.d/blacklist.conf</code></pre>
<pre><code>blacklist &lt;MODULE&gt;</code></pre>
<p>[1]</p>
<p>Source:</p>
<ol style="list-style-type: decimal">
<li>&quot;Kernel modules.&quot; The Arch Linux Wiki. August 8, 2016. Accessed November 19, 2016. https://wiki.archlinux.org/index.php/Kernel_modules</li>
</ol>
<h2 id="linux---io-schedulers">Linux - I/O Schedulers</h2>
<p>The kernel provides many input/output (I/O) schedulers to configure how a hard drive handles a queue of read/write requests from the operating system. Different schedulers can be uesd to adjust performance based on the hardware and/or software requirements.</p>
<ul>
<li>Deadline = Large I/O requests are done in high-priority sectors until smaller I/O requests are about to time out. Then Deadline takes care of the small tasks before continuing with the original large I/O task. This is ideal for heavy read/write applications on a spinning disk drive.</li>
<li>Complete Fariness Queueing (CFQ) = All I/O requests are treated equally and are handled in the order that they are recieved. [1]</li>
<li>NOOP = Only basic merging of read and/or write requests and no rescheduling. This is ideal for virtual drives (such as QCOW2) where the hypervisor node handles the I/O scheduling. [2] This is also ideal for physical flash based media where the hardware's firmware takes care of the sorting. [1]</li>
</ul>
<p>Temporarily change the scheduler to one of the three options:</p>
<pre><code># echo {deadline|cfg|noop} &gt; /sys/block/&lt;DEVICE&gt;/queue/scheduler</code></pre>
<p>Permanently change the scheduler by appending the existing GRUB_CMDLINE_LINUX kernel arguments:</p>
<pre><code># vim /etc/default/grub
GRUB_CMDLINE_LINUX=&quot;elevator={deadline|cfg|noop}&quot;
# grub-mkconfig -o /boot/grub/grub.cfg</code></pre>
<p>[2]</p>
<p>Sources:</p>
<ol style="list-style-type: decimal">
<li>Linux System Programming. (Love: Oâ€™Reilly Media, Inc., 2007).</li>
<li>&quot;What is the suggested I/O scheduler to improve disk performance when using Red Hat Enterprise Linux with virtualization?&quot; Red Hat Knowledgebase. December 16, 2016. Accessed December 18, 2016. https://access.redhat.com/solutions/5427</li>
</ol>
<h1 id="initial-ram-filesystem">Initial RAM Filesystem</h1>
<p>The initramfs (inital RAM filesystem) is used to boot up a system before loading the full Linux kernel. It is the successor to the initrd (inital RAM disk). A boot loader, such as GRUB, loads the initramfs first. This usually contains a minimum copy of the kernel and drivers required to boot up the system. Once the boot initalization is complete, the initramfs continues to load all of the available kernel modules. [1][2]</p>
<p>Sources:</p>
<ol style="list-style-type: decimal">
<li>'The Kernel Newbie Corner: &quot;initrd&quot; and &quot;initramfs&quot;--What's Up With That?' Linux.com September 30, 2009. Accessed November 19, 2016. https://www.linux.com/learn/kernel-newbie-corner-initrd-and-initramfs-whats</li>
<li>&quot;ramfs, rootfs and initramfs.&quot; The Linux Kernel Documentation. May 29, 2015. Accessed November 19, 2016. https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt</li>
</ol>
<h2 id="initial-ram-filesystem---arch-linux">Initial RAM Filesystem - Arch Linux</h2>
<p>All modifications of the initramfs in Arch Linux are handled by the &quot;mkinitcpio&quot; utility.</p>
<pre><code>/etc/mkinitcpio.conf</code></pre>
<ul>
<li>MODULES = A list of kernel modules to compile in.</li>
<li>FILES = A list of files that should be included in the initramfs.</li>
<li>BINARIES = A list of binaries that should be included to use in the initramfs environment. This is useful for having more recovery utilies. The &quot;mkinitcpio&quot; program will automatically detect the binary's depdencies and add them to the initramfs image.</li>
<li>HOOKS = Custom hooks for compiling in certain software packages.
<ul>
<li>Common hooks:
<ul>
<li>btrfs = BtrFS RAID.</li>
<li>net = Add networking.</li>
<li>mdadm = mdadm software RAID modules.</li>
<li>fsck = FSCK utilies for available operating systems.</li>
<li>encrypt = LUKS encyrption modules.</li>
<li>lvm2 = Logical volume manager (LVM) modules.</li>
<li>shutdown = Allows the initramfs to properly shutdown.</li>
</ul></li>
</ul></li>
</ul>
<p>Create a new initramfs.</p>
<pre><code># mkinitcpio</code></pre>
<p>[1]</p>
<p>Source:</p>
<ol style="list-style-type: decimal">
<li>&quot;mkinitcpio.&quot; The Arch Linux Wiki. November 13, 2016. Accessed November 19, 2016. https://wiki.archlinux.org/index.php/mkinitcpio</li>
</ol>
<h2 id="initial-ram-filesystem---rhel">Initial RAM Filesystem - RHEL</h2>
<p>On Red Hat Enterprise Linux (RHEL) based operating systems (such as RHEL itself, CentOS, and Fedora), Dracut is used to manage the initramfs.</p>
<pre><code>/etc/dracut.conf</code></pre>
<ul>
<li>add_drivers+= A list of kernel modules to compile in.</li>
<li>install_items+= A list of files to compile in.</li>
<li>add_dracutmodules+= A list of Dracut modules to compile.</li>
</ul>
<p>Source:</p>
<ol style="list-style-type: decimal">
<li>&quot;Dracut.&quot; The Linux Kernel Archives. October, 2013. Accessed November 19, 2016. https://www.kernel.org/pub/linux/utils/boot/dracut/dracut.html</li>
</ol>
