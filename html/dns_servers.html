<h1 id="dns">DNS</h1>
<ul>
<li><a href="#introduction-to-dns">Introduction to DNS</a></li>
<li>BIND</li>
<li>Dnsmasq</li>
<li><a href="#powerdns">PowerDNS</a></li>
<li><a href="#powerdns---poweradmin">PowerAdmin</a></li>
<li><a href="#powerdns---gmysql">gmysql</a></li>
<li>Unbound</li>
</ul>
<h2 id="introduction-to-dns">Introduction to DNS</h2>
<p>Domain Name Servers (DNS) provide friendly domain names that are generally associated with an IP address or a string of text. There are two types of DNS servers:</p>
<ul>
<li>Authoritative = Serves it's own DNS records. Generally most authoritative servers will rely on a recursive component to provide missing DNS records.</li>
<li>Recursive = Queries an external DNS server for records. These are usually then cached for a certain period of time.</li>
</ul>
<p>It is important to note that every DNS record has to be associated with a state of authority (SOA) record. This provides the primary nameserver/resolver along with time to live (TTL) related information.</p>
<h2 id="powerdns">PowerDNS</h2>
<p>The pdns service can be both an authoritative and recursive DNS server. It supports a large number of backends that can be used for it's authorative server. [1] A few of the most popular backends are &quot;bind&quot; (BIND) due to it's large usage in the Linux community and &quot;gmysql&quot; (MySQL) due to it's scalability.</p>
<p>This is the SOA format that pdns uses. At the bare minimum, the nameserver and email should be defined. [3]</p>
<pre><code>nameserver email serial refresh retry expire ttl</code></pre>
<p>SOA options:</p>
<ul>
<li>nameserver = The DNS server that should host the zone information. This value should normally mirror one of the NS records used for the zone (if applicable).</li>
<li>email = The administrator's e-mail.</li>
<li>serial = 0 for automatic serial creation (default). Not all backends support automatic serials, such as bind. gmysql supports it. If using automatic serial numbers, place the number here. If any records are updated, the serial should also be updated.</li>
<li>refresh = When DNS servers should check for DNS updates (in seconds).</li>
<li>retry = How long to wait (in seconds) to recheck the zone after a failed refresh.</li>
<li>expire = How long (in seconds) before this zone should longer be queired for a failed retry. This value only applies to slave DNS servers.</li>
<li>ttl = How long (in seconds) a record is allowed to be cached by another DNS server. [5]</li>
</ul>
<h3 id="powerdns---poweradmin">PowerDNS - PowerAdmin</h3>
<p>PowerAdmin is the graphic control panel that can be installed and accessed via a web browser.</p>
<h3 id="powerdns---gmysql">PowerDNS - gmysql</h3>
<p>The generic MySQL backend (gmysql) was created to allow any MySQL server store and serve records. [2] This is not to be confused with using the MyDNS backend. [1]</p>
<p>This is the recommend InnoDB table schema to use. [2]</p>
<pre><code>CREATE DATABASE IF NOT EXISTS pdns;

CREATE TABLE pdns.domains (
  id                    INT AUTO_INCREMENT,
  name                  VARCHAR(255) NOT NULL,
  master                VARCHAR(128) DEFAULT NULL,
  last_check            INT DEFAULT NULL,
  type                  VARCHAR(6) NOT NULL,
  notified_serial       INT DEFAULT NULL,
  account               VARCHAR(40) DEFAULT NULL,
  PRIMARY KEY (id)
) Engine=InnoDB;

CREATE UNIQUE INDEX name_index ON pdns.domains(name);

CREATE TABLE pdns.records (
  id                    INT AUTO_INCREMENT,
  domain_id             INT DEFAULT NULL,
  name                  VARCHAR(255) DEFAULT NULL,
  type                  VARCHAR(10) DEFAULT NULL,
  content               VARCHAR(64000) DEFAULT NULL,
  ttl                   INT DEFAULT NULL,
  prio                  INT DEFAULT NULL,
  change_date           INT DEFAULT NULL,
  disabled              TINYINT(1) DEFAULT 0,
  ordername             VARCHAR(255) BINARY DEFAULT NULL,
  auth                  TINYINT(1) DEFAULT 1,
  PRIMARY KEY (id)
  CONSTRAINT `records_ibfk_1` FOREIGN KEY (`domain_id`) REFERENCES `domains` (`id`) ON DELETE CASCADE
) Engine=InnoDB;

CREATE INDEX nametype_index ON pdns.records (name,type);
CREATE INDEX domain_id ON pdns.records (domain_id);
CREATE INDEX recordorder ON pdns.records (domain_id, ordername);

CREATE TABLE pdns.supermasters (
  ip                    VARCHAR(64) NOT NULL,
  nameserver            VARCHAR(255) NOT NULL,
  account               VARCHAR(40) NOT NULL,
  PRIMARY KEY (ip, nameserver)
) Engine=InnoDB;

CREATE TABLE pdns.comments (
  id                    INT AUTO_INCREMENT,
  domain_id             INT NOT NULL,
  name                  VARCHAR(255) NOT NULL,
  type                  VARCHAR(10) NOT NULL,
  modified_at           INT NOT NULL,
  account               VARCHAR(40) NOT NULL,
  comment               VARCHAR(64000) NOT NULL,
  PRIMARY KEY (id)
) Engine=InnoDB;

CREATE INDEX comments_domain_id_idx ON pdns.comments (domain_id);
CREATE INDEX comments_name_type_idx ON pdns.comments (name, type);
CREATE INDEX comments_order_idx ON pdns.comments (domain_id, modified_at);

CREATE TABLE pdns.domainmetadata (
  id                    INT AUTO_INCREMENT,
  domain_id             INT NOT NULL,
  kind                  VARCHAR(32),
  content               TEXT,
  PRIMARY KEY (id)
) Engine=InnoDB;

CREATE INDEX domainmetadata_idx ON pdns.domainmetadata (domain_id, kind);

CREATE TABLE pdns.cryptokeys (
  id                    INT AUTO_INCREMENT,
  domain_id             INT NOT NULL,
  flags                 INT NOT NULL,
  active                BOOL,
  content               TEXT,
  PRIMARY KEY(id)
) Engine=InnoDB;

CREATE INDEX domainidindex ON pdns.cryptokeys (domain_id);

CREATE TABLE pdns.tsigkeys (
  id                    INT AUTO_INCREMENT,
  name                  VARCHAR(255),
  algorithm             VARCHAR(50),
  secret                VARCHAR(255),
  PRIMARY KEY (id)
) Engine=InnoDB;

CREATE UNIQUE INDEX namealgoindex ON pdns.tsigkeys (name, algorithm);</code></pre>
<p>Then make sure that the pdns service is configured via the &quot;pdns.conf&quot; file to connect to the MySQL server.</p>
<pre><code>launch=gmysql
gmysql-host=127.0.0.1
gmysql-user=root
gmysql-dbname=pdns
gmysql-password=&lt;PASS&gt;</code></pre>
<p>After pdns is configured to use gmysql, a domain's zone can be added. Here is an example. Notice that the pdns.domains table needs to first have an entry for the domain. That new insert will generate an &quot;id&quot;. That ID should be refereneced as the &quot;domain_id&quot; in the pdns.records table or else the record will not resolve. In this case, the &quot;id&quot; was 1 and the domain name for the zone is &quot;test.tld&quot;. [3]</p>
<pre><code>mysql&gt; USE pdns;
INSERT INTO domains (name, type) values (&#39;test.tld&#39;, &#39;NATIVE&#39;);
INSERT INTO records (domain_id, name, content, type, ttl)
VALUES (1, &#39;test.tld&#39;, &#39;localhost admin@test.tld 0&#39;, &#39;SOA&#39;, 86400);
INSERT INTO records (domain_id, name, content, type, ttl)
VALUES (1,&#39;test.tld&#39;,&#39;dns1.nameserver.tld&#39;, &#39;NS&#39;, 86400);
INSERT INTO records (domain_id, name, content, type, ttl)
VALUES (1, &#39;test.tld&#39;, &#39;dns2.nameserver.tld&#39;, &#39;NS&#39;, 86400);
INSERT INTO records (domain_id, name, content, type, ttl)
VALUES (1, &#39;www.test.tld&#39;, &#39;192.168.0.10&#39;, &#39;A&#39;, 3600);</code></pre>
<p>For records tables, the most important colums are:</p>
<ul>
<li>name = The domain name that will correspond to a record. This record should never end with a &quot;.&quot;</li>
<li>type = The type of DNS record. This can be SOA, A, AAAA, MX, SRV, PTR, etc.</li>
<li>content = What the name should resolve to when queried.</li>
</ul>
<p>PTR records require that the IP address be defined int he nibble format. This special format is basically the IP address in reverse with special suffixes added to the end. For helping to quickly get the format for long IPv6 addresses, use the &quot;ipv6calc&quot; command or this site <a href="http://rdns6.com/hostRecord" class="uri">http://rdns6.com/hostRecord</a>.</p>
<pre><code>&lt;NIBBLE_IP4&gt;.in-addr.arpa.
&lt;NIBBLE_IP6&gt;.ip6.arpa.</code></pre>
<p>Here is an example of converting addresses to nibble.</p>
<ul>
<li>IPv4 address = 192.168.0.10</li>
<li>IPv4 nibble address = 10.0.168.192.in-addr.arpa.</li>
<li>IPv6 address = FE8::56:CC7A:129B:7AAA (FE80:0000:0000:0000:056:CC7A:129B:7AAA)</li>
<li><p>IPv6 nibble address = a.a.a.7.b.9.2.1.a.7.c.c.6.5.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.e.f.ip6.arpa</p>
<pre><code>$ ipv6calc --out revnibbles.arp FE8::56:CC7A:129B:7AAA</code></pre></li>
</ul>
<p>Sources:</p>
<ol style="list-style-type: decimal">
<li>&quot;PowerDNS.&quot; PowerDNS Docs. Accessed July 7, 2016. https://doc.powerdns.com/md/</li>
<li>&quot;PowerDNS Generic MySQL backend.&quot; PowerDNS Docs. Accessed July 7, 2016. https://doc.powerdns.com/md/authoritative/backend-generic-mysql/</li>
<li>&quot;PowerDNS How To's&quot; PowerDNS Docs. Accessed July 7, 2016. https://doc.powerdns.com/md/authoritative/howtos/</li>
<li>&quot;Supported Record Types. PowerDNS Docs. Accessed July 7, 2016. https://doc.powerdns.com/md/types/</li>
<li>&quot;Start of Authority Resource Record (SOA RR).&quot; zytrax open. Accessed July 7, 2016. http://www.zytrax.com/books/dns/ch8/soa.html</li>
</ol>
